
//3/20 강의문 

/*  OOP 객체지향 프로그래밍이란
 * 	컴터 프로그램을 여러개의 독립된 단위(객체)들의 모임으로 파악하는것 
 * 
 * 객체는 데이터와 그 데이터를 처리할수있는 메서드를 갖는다?
 * //객체라하는것은 데이터와 그 데이터를 처리할수 있는 기능들을 함께 들고 다닌다라는 뜻
 * //사람이라 하는 존재는 이름이라하는, 나이라하는 데이터를가질수 잇을때 이름, 나이가 바로 데이터인거고 
 * //사람이라 하는 존재는 어떤 기능을 할수 있을까 걷다,먹다, 등의 기능이 있다
 * //이런식으로 특정 데이터와 특정 기능을 묶어서 함께 가지고 다니는 것을 객체라고 할수 있는것

 * 최대 목적:
 * //소프트웨어의 부품화, 재사용을 주요 목표로 함 
 * //코드의 재사용이 높은편이고 코드의 관리가 쉬워진다는 장점 있음
 * //현실세계의 객체들이 기능이 많아지고 복잡해짐으로서 현실세계를 시뮬레이션 할 필요의 대두/새개발방법을 만들게됨
 * //개발과 유지보수에 강점이고 직관적 코드 분석을 가능하게 한다 
 * //신뢰도 높은 프로그램 개발을 가능하게 한다 
 *  나중에 어떤 문제 오류가 났을때 어디를 고쳐야 하는지가 보임 ,,
 *  미리 만들어놓고 나중에 프로젝트할때 갖다 쓰겠다는 내용   
*=====================================================================
 *  //has와 is의 관계 
 *  //책장과 책의 관계를 표현해보면//
 * ex)책장 has book // 해리포터 is a book   
 * 책장은 책을 저장하는 공간을 가지고 있다(속성)//책장은 책들을 그래서 갖고있다->*책장은 책을 보유할수있다(관계) 
 * 책은 isbn번호, 가격, 저자, 제목을 가지고 있다(속성)
 * 책장은 자신이 갖고 있는 속성을 이용하는 기능을 갖고있다 

 * 도서대여점 객체지향 설계
 *	도서대여점 고객의 데이터와 신발가게고객의 데이터로 커스텀할 경우 
 *	//도서대여점고객은 이름,연락처가 중요하며, 신발가게에서는 신발사이즈가 중요하지 이름,연락처등이 중요하지않음
 *	//따라서 위에서처럼 중요한건 남기고 불필요한건 없애는걸 객체지향에서는 추상화라고 한다
 *	객체지향 프로그램은 관점에 따라 객체가 가지는 속성과 기능을 다르게 표현하게 된다 /관점 중요
 *
 * 객체지향이 추구하는바/결론
 * 1)필요한것만남기고 불필요한것 제거하는 추상화시키자
 * 2)관점잘파악후 그요구사항에맞게 설계하면 재사용이 가능해진다
 * 3)설계도를 그려두면 양산이 가능해진다 
 * ===================================================================
 * 객체지향 기본 개념 [클래스,인스턴스,레퍼런스];
 * 클래스 ==설계도라 생각하기 /
 * 클레스를 메모리에 올리는 작업을 인스턴스화라하며/
 * 실제 올리는 그 객체를 인스턴스,
 * 참조하는 변수를 레퍼런스라고 한다
 * 책 b1 = new 책(); // 레퍼런스타입 레퍼런스변수 = 인스턴스생성키워드 생성자 //
 * null은 연결을 끊는다는것
 * 
 * 자동차는 부모클래스// 그아래 버스, 스포츠카, 포크레인은 자식 클래스라 말할수 있음
 * 버스,스포츠카,포크레인을 일반화한것은 자동차 (셋을 일봔화한것은 즉 공통점을 찾은것은 자동차)
 * 자동차를 상속한것은 버스, 스포츠카, 포크레인이라 말할수 있다 (확장은 더 이후에 다른것 추가됨)
 * 
 * ex) 
 	Bus is a car.
 	Sportscar is a car.
 	forkcrane is a car.
 
 * 자식클래스로 생성된 인스턴스들은 부모클래스로 참조할수 잇다
 * == 조상 타입의 레퍼런스 변수는 후손 인스턴스를 레퍼런스 할수 있다
 	자동차 c1 = new 버스();
 	자동차 c2 = new 스포츠카();
 	자동차 c3 = new 포크레인();
 
 *	버스 bus = new 버스();
 	스포츠카 sportCar = new 스포츠카();
 	자동차 poclain = new 포크레인();
 * ===================================================================
 * 버스 주차를 요청하니 안내방송을 실행
	스포츠카 주차를 요청하니 지붕을 열고 닫음
	포크레인 주차를 요청하니 땅을 파고 있음
	//자동차의 주인은 자동차의 기본 기능만 이용하여 주차하길 바란다.

 * 버스 bus1 = new 버스();
	bus1.달리다();
	bus1.뒷문열다();
	bus1.안내방송하다(); 

//버스와 그 조상 설계도에 있는 기능만 사용 가능하다 // 즉 달리다만 사용가능
 * 자동차 bus2 = new 버스();
	bus2.달리다();
	bus2.뒷문열다(); (X)
	bus2.안내방송하다(); (X) 
	설계도에 구현된 부분이외의 기능은 사용할 수 없다.
 * ===================================================================
 * 스포츠카는 자동차가 가지고 있는 본래의 "달리다" 기능을
자신만의 구동방식으로 바꾸고자 합니다.
부모의 기능과 완전히 같은 모양으로 내용을 다시 선언
-> 메서드 오버라이드

* 자동차 bus = new 버스();	
	bus.달리다();   //전륜구동이라 한다면//
	bus.뒷문열다(); (X)
	bus.안내방송하다(); (X)
//
* 자동차 spoCar = new 스포츠카();
	spoCar.달리다(); //후륜구동//덮어쓰기기능이지만 덮어쓴다해서 기능이 없어지는건 아님
	spoCar.뒷문열다(); (X)
	spoCar.안내방송하다(); (X)
	/// but 오벌로드와 혼동주의
 * ===================================================================
 * 주차 공간의 확보
자동차 bus1= new 버스();
자동차 spo1= new 스포츠카();
자동차 pocl1= new 포크레인();

자동차[] carArray = new 자동차[15]
carArray[0] = bus1;
carArray[1] = spo1;
carArray[2] = fork1;

버스[] busArray = new 버스[5]
스포츠카[] spoArray = new 스포츠카[5]
포크레인[] poclArray = new 포크레인[5]
 * 
 * 
 *====================================================================
 *====================================================================
 *
 *
 *03. java OOP Programmming 강의자료
 *  객체란 현실세계를 시뮬레이션한다는 특징이 있다 즉
 *  실세계에 존재하는 사물 또는 개념을 말한다
 *  정보를 효율적 관리위해 의미를 부여하고 분류하는 논리적 단위이고
 *  다른 객체와 서로 상호작용하며 동작한다
 *  
 *  객체의 구성요소
 *  객체는 속성(정보)과 동작(기능)의 집합이다 ->이를 묶어서 객체의 멤버( 구성요소)라고 한다
 *  속성은 필드, 동작은 메서드로 정의할수 있다.
 *  
 *  클래스는 객체를 정의해놓은것 
 *  객체가 붕어빵이면 클래스는 붕어빵 기계가 되는것 .. 
 *  붕어빵기계라는 클래스로 붕어빵을 계속 찍어낼수 있다
 *  즉 객체를 생성하는데 사용되는 설계도를 말한다 
 *  
 *  Instance
 *  객체는 인스턴스의 일반적 의미
 *  클래스를 기반으로 객체가 (힙)메모리에 할당되어 
 *  실제 사용가능한 상태(cpu가 읽을수 있는 상태가 되었을때)일때 인스턴스라고 한다//
 *  인스턴스화는 클래스로부터 인스턴스를 생성하는 것을 말함
 * 	
 *  객체지향 네가지 특성
 *  상속성
 *  	이미 만든 객체와 비슷하지만 필드와 메서드가 약간 차이나는 객체를 생성
 *  		기존의 클래스에서 공통된 필드와 메서드를 상속받는다(재사용)
 *  		이후 더 필요한 필드와 메서드를 추가한다
 *  	코드를 더 간결하게 하고 코드의 재사용성을높인다 /중복코딩 줄이기
 *  	ex) employee는 person을 상속받아서 확장해서 임플로이를 만들었다
 *  
 *  캡슐화 - 정보은닉 
 *  	객체의 실제 구현된 내용을 감추고 접근 방법만 노출하는것 
 *  	외부 객체(객체를 사용하는쪽)에서는 객체의 내부 구조를 알지 못하며
 *  	객체가 노출하여 제공하는 필드와 메서드만 이용할수 있음
 *  		ex. BA ba = new BA(); //ba는 참조변수라할때
 *  	BA에서 balance잔고는 가리고 , deposit입금의 기능만 허용하는 경우 
 *  	외부에서 고의던 실수던 잘못된 사용, 해킹으로 인한 객체 내부데이터가 손상되는것을 피하기 위함
 *  	접근제한자(Access Modifier)를 사용하여 객체의 필드와 메서드의 사용범위를 제한할수 있다
 *  
 *  다형성
 *  	하나의 메서드나 클래스를 다양한 구현으로 사용 가능케 하는 개념
 *  	오버로드(한가지 이름을 가진 메소드)와 혹은 오버라이드(덮어쓰기)를 통해 다형성 구현가능
 *  
 *  
 *  추상화
 *  
 *  ==============================================================
 *  클래스의 구조
public class Car {  //클래스 헤더 

	private String name;		->내부 필드
	private int speed;			//필드(데이터)//private는 나만 쓸수있다는표시
	
	public Car(){ }
	
	public Car(String name, int speed){
		this.name=name;
		this.speed=speed;
	}										// 여기까지 생성자

	public void setName( String name ) {  //외부파라미터 외부로부터 name이란 값을 전달받음
		this.name = name;                 //this(인스턴스자신) name은 외부로부터 전달받은 네임을 할당받는다
	}
	public String getName() {
		return name;
	}										//메소드						
}
 * ================================================================= 
 *  필드
 *  필드는 객체의 데이터, 상태를 저장하는 변수이며
 *  주로 기본타입 또는 참조타입으로 정의하고 멤버 변수라고도 한다
 *  
 * 1번문제
쇼핑몰에서 상품을 관리하기 위해 상품관리 프로그램을 만들려고 합니다. 
프로그램을 만들기 전에 업무(비즈니스)분석을 통해 상품 객체를 분석하고 
다음과 같은 Goods클래스를 정의 하였습니다.

Goods 클래스를 정의하고 GoodsApp 클래스에서 Goods 클래스를 테스트 하세요.
1) Goods 객체를 하나 생성하고 이 객체에 대한 레퍼런스 변수를 camera 로 합니다.
2) 이 객체의 데이터인 각 각의 인스턴스 변수는 다음과 같은 값을 가지도록 합니다.
상품이름 : “nikon”, 가격: 400000
3) 값을 세팅 한 후, 객체의 데이터를 출력해 보세요.
 
 
  * ===========================================
 * 접근자( Access Modifier)
 * 정보은닉위한 방법(캡슐화)
 * 정보접근수준에따라 public, protected, default, private 4가지가 있다
 *  .//패키지 안쪽에 클래스 있을경우 지시자를 명시하지 않거나 디폴트를 쓰게되면 디폴트상태됨
 *
 *  
 * 접근자 연습하기 
- Goods 클래스의 필드 접근자를 public으로 변경해 봅니다.
- Goods 클래스의 필드 접근자를 default보다 강한 접근 제어자인 
  private로 지정하여 어떤 변화가 있는 지 확인해봅니다.
 * 
 * =========================================
 */

//0322

/*Getter, Setter
* 일반적으로 객체의 데이터는 객체 외부에서 직접적으로 접근하는 것을 막는다.
객체의 외부에서 객체 내부의 데이터를 마음대로 읽고 쓸 경우 데이터의 무결성을 보장하기 힘들기 때문이다.
메소드를 통한 접근을 하게 되면 객체의 데이터를 변경할 경우 무결성 체크를 할수 있다.
✓ 클래스를 정의할 때 필드는 private로 하여 객체 내부의 정보를 보호하고(정보은닉)
필드에 대한 Setter와 Getter를 두어 객체의 값을 변경하고 참조하는 것이 좋다.
– 외부에서 읽기만 가능하게 하기 위해선 Getter만 해당 필드에 대해서만 작성하면 된다.
– 외부에서 쓰기만 가능하게 하기 위해선 Setter만 해당 필드에 대해서만 작성하면 된다.
– Getter와 Setter가 없으면 객체 내부 전용 변수가 된다.
– 보통 Getter는 getXXX로 명명하지만, 필드 타입이 boolean인 경우 isXXX로 명명하는 것이
관례

* 
*
*
*
*
*
*/


package com.javaex.oop.goods.v2;

// v2. private
public class Goods {
	
	//필드 선언해주기
	// instance 영역
	private String name;	//상품명 string name선언 앞에 private가 들어감(goodsapp으로 접근불가)
	private int price;		//가격
	
	//이후 GoodsApp 클래스를 따로 만들러가기->->->
	
	//위에서 private를 선언했기때문에 GoodsApp클래스로 가면 오류가 뜨지만
	//Getter와 Setter를 이용해서 get,set설정 해주면 외부에서 읽고/ 쓰기만 설정을 가능하게 할수 있음
	
	//0322
	//Getter 와 Setter-----------------------
	public String getName() {
		//메서드 영역 
		return name;
	}
	
    public void setName(String name) {
    	this.name = name;
    }//------------------------------------
    
    public int getPrice() {
    	return price;
    }
    
    public void setPrice(int price) {
    	//getter/setter를 활용하면 무결성 체크,
    	//인증 체크 같은 로직을 수행 가능 
    	if (price < 0) {
    		this.price = 0;
    	} else {
    		this.price = price;
    	}
    	
    }//------------------------------------
    
    
    //일반 메서드
    public void showInfo() {	//정보출력을 위함
    	System.out.printf("상품 이름: %s%n가격: %,d%n", name, price);
    }
    
    
    
}

















